//! TDN crypto utils.

use aes_gcm::{aead::Aead, Aes256Gcm, KeyInit};
use pbkdf2::{hmac::SimpleHmac, pbkdf2};
use tls_core::rand;

#[derive(Clone, Debug, thiserror::Error)]
#[allow(missing_docs)]
pub enum TdnCryptoError {
    #[error("Cannot derive key: {0}")]
    DeriveKeyError(String),
}

pub(crate) const DEFAULT_ITERATIONS: u32 = 10_000;

/// Key generated by derivation process.
pub struct DerivedKey {
    /// Derived key.
    pub key: Vec<u8>,
    /// Salt used in the derivation process.
    pub salt: Vec<u8>,
}

/// Symmetric encryption result.
pub struct EncryptedData {
    /// Encrypted ciphertext.
    pub ciphertext: Vec<u8>,
    /// IV / nonce.
    pub iv: Vec<u8>,
}

/// PBKDF2 key derivation. HMAC with BLAKE3 is used.
///
/// # Arguments
///
/// * `pwd` - Password.
/// * `salt` - Salt (optional, randomly generated when not specified, 16 bytes).
/// * `iterations` - Iterations (optional, by default [DEFAULT_ITERATIONS]).
///
/// # Returns
///
/// Key derivation result. The key is 32 bytes.
pub fn derive_key_pbkdf2(
    pwd: &str,
    salt: Option<&[u8; 16]>,
    iterations: Option<u32>,
) -> Result<DerivedKey, TdnCryptoError> {
    // Generate salt if not provided.
    let salt = match salt {
        Some(s) => s.to_vec(),
        None => {
            let mut s = vec![0; 16];
            rand::fill_random(&mut s).map_err(|e| TdnCryptoError::DeriveKeyError(e.to_string()))?;
            s
        }
    };

    let iterations = iterations.unwrap_or(DEFAULT_ITERATIONS);

    // Derive a key using PBKDF2.
    let mut key = [0u8; 32];
    pbkdf2::<SimpleHmac<blake3::Hasher>>(&pwd.as_bytes(), &salt, iterations, &mut key)
        .map_err(|e| TdnCryptoError::DeriveKeyError(e.to_string()))?;

    Ok(DerivedKey {
        key: key.to_vec(),
        salt,
    })
}

/// AES-256 GCM symmetric encryption.
///
/// # Arguments
///
/// * `key` - Key (32 bytes).
/// * `nonce` - Nonce (optional, randomly generated when not specified, 12 bytes for GCM).
/// * `data` - Data to encrypt.
///
/// # Returns
///
/// Encrypted data.
pub fn symmetric_encrypt_aes256_gcm(
    key: &[u8],
    data: &[u8],
    nonce: Option<&[u8; 12]>,
) -> Result<EncryptedData, TdnCryptoError> {
    let nonce = match nonce {
        Some(nonce) => nonce.to_owned(),
        None => {
            let mut nonce = [0u8; 12];
            rand::fill_random(&mut nonce)
                .map_err(|e| TdnCryptoError::DeriveKeyError(e.to_string()))?;
            nonce
        }
    };

    let cipher = Aes256Gcm::new_from_slice(key)
        .map_err(|e| TdnCryptoError::DeriveKeyError(e.to_string()))?;
    let ciphertext = cipher
        .encrypt(&nonce.into(), data)
        .map_err(|e| TdnCryptoError::DeriveKeyError(e.to_string()))?;

    Ok(EncryptedData {
        ciphertext,
        iv: nonce.to_vec(),
    })
}

/// Perform direct asymmetric encryption using the given public key.
/// The key should be in SEC1 uncompressed format.
/// Note that direct asymmetric encryption is only suitable for small and ephemeral data.
pub fn direct_asymmetric_encrypt(pub_key: &[u8], data: &[u8]) -> Vec<u8> {
    pub_key
        .iter()
        .zip(data.iter())
        .map(|(b, d)| b ^ d)
        .collect()
}
