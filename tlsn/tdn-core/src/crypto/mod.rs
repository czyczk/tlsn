//! TDN crypto utils.

use aes_gcm::{
    aead::{Aead, OsRng},
    Aes256Gcm, KeyInit,
};
use k256::elliptic_curve::sec1::ToEncodedPoint as _;
use pbkdf2::{hmac::SimpleHmac, pbkdf2};
use serde::{Deserialize, Serialize};
use tls_core::rand;

#[derive(Clone, Debug, thiserror::Error)]
#[allow(missing_docs)]
pub enum TdnCryptoError {
    #[error("Cannot derive key: {0}")]
    DeriveKeyError(String),
    #[error("Cannot load key: {0}")]
    LoadKeyError(String),
    #[error("Encryption error: {0}")]
    EncryptionError(String),
}

pub(crate) const DEFAULT_ITERATIONS: u32 = 10_000;

/// A private key used for serde, ECDSA or ECDH.
#[derive(Debug, Clone)]
#[non_exhaustive]
pub enum PrivateKey {
    /// A NIST P256 private key.
    P256(p256::SecretKey),
    /// A secp256k1 private key.
    Secp256k1(k256::SecretKey),
}

/// A public key used for serde, ECDSA or ECDH.
#[derive(Debug, Clone, Deserialize, Serialize)]
#[non_exhaustive]
pub enum PublicKey {
    /// A NIST P256 public key.
    P256(p256::PublicKey),
    /// A secp256k1 public key.
    Secp256k1(k256::PublicKey),
}

/// Key generated by derivation process.
pub struct DerivedKey {
    /// Derived key.
    pub key: Vec<u8>,
    /// Salt used in the derivation process.
    pub salt: Vec<u8>,
}

/// Symmetric encryption result.
pub struct EncryptedData {
    /// Encrypted ciphertext.
    pub ciphertext: Vec<u8>,
    /// IV / nonce.
    pub iv: Vec<u8>,
}

/// Hybrid encryption result.
pub struct HybridEncryptedData {
    /// Encrypted ciphertext.
    pub ciphertext: Vec<u8>,
    /// Salt.
    pub salt: Vec<u8>,
    /// IV / nonce.
    pub iv: Vec<u8>,
    /// Ephemeral public key.
    pub ephemeral_pub_key: Vec<u8>,
}

impl PrivateKey {
    /// Serializes the private key / scalar into big-endian bytes.
    pub fn to_bytes(&self) -> Vec<u8> {
        match self {
            Self::P256(key) => key.to_bytes().to_vec(),
            Self::Secp256k1(key) => key.to_bytes().to_vec(),
        }
    }
}

impl From<p256::SecretKey> for PrivateKey {
    fn from(key: p256::SecretKey) -> Self {
        Self::P256(key)
    }
}

impl From<k256::SecretKey> for PrivateKey {
    fn from(key: k256::SecretKey) -> Self {
        Self::Secp256k1(key)
    }
}

impl From<secp256k1::SecretKey> for PrivateKey {
    fn from(key: secp256k1::SecretKey) -> Self {
        let bytes = key.secret_bytes();
        let k256_private_key = k256::SecretKey::from_slice(&bytes).unwrap();
        Self::Secp256k1(k256_private_key)
    }
}

impl PublicKey {
    /// Serializes the public key to SEC1 uncompressed bytes.
    pub fn to_bytes(&self) -> Vec<u8> {
        match self {
            Self::P256(key) => key.to_encoded_point(false).as_bytes().into(),
            Self::Secp256k1(key) => key.to_encoded_point(false).as_bytes().into(),
        }
    }

    /// Serializes the public key to SEC1 compressed bytes.
    pub fn to_bytes_compressed(&self) -> Vec<u8> {
        match self {
            Self::P256(key) => key.to_sec1_bytes().to_vec(),
            Self::Secp256k1(key) => key.to_sec1_bytes().to_vec(),
        }
    }
}

impl From<p256::PublicKey> for PublicKey {
    fn from(key: p256::PublicKey) -> Self {
        Self::P256(key)
    }
}

impl From<k256::PublicKey> for PublicKey {
    fn from(key: k256::PublicKey) -> Self {
        Self::Secp256k1(key)
    }
}

impl From<secp256k1::PublicKey> for PublicKey {
    fn from(key: secp256k1::PublicKey) -> Self {
        let bytes = key.serialize_uncompressed();
        let k256_public_key = k256::PublicKey::from_sec1_bytes(&bytes).unwrap();
        Self::Secp256k1(k256_public_key)
    }
}

impl TryFrom<tls_core::key::PublicKey> for PublicKey {
    type Error = TdnCryptoError;

    fn try_from(value: tls_core::key::PublicKey) -> Result<Self, Self::Error> {
        match value.group {
            tls_core::msgs::enums::NamedGroup::secp256r1 => {
                p256::PublicKey::from_sec1_bytes(&value.key)
                    .map_err(|e| {
                        TdnCryptoError::LoadKeyError(format!(
                            "Invalid public key: {}",
                            e.to_string()
                        ))
                    })
                    .map(Self::P256)
            }
            _ => Err(TdnCryptoError::LoadKeyError(format!(
                "Unsupported key group: {:?}",
                value.group
            ))),
        }
    }
}

impl EncryptedData {
    /// Serializes [EncryptedData] together with a salt. The order is ciphertext, salt, IV.
    pub fn serialize_with_nonce(&self, salt: &[u8]) -> Vec<u8> {
        let mut result = Vec::with_capacity(self.ciphertext.len() + salt.len() + self.iv.len());
        result.extend_from_slice(&self.ciphertext);
        result.extend_from_slice(&salt);
        result.extend_from_slice(&self.iv);
        result
    }
}

impl HybridEncryptedData {
    /// Serializes [HybridEncryptedData]. The order is ciphertext, salt, IV, ephemeral public key.
    pub fn serialize(&self) -> Vec<u8> {
        let mut result = Vec::with_capacity(
            self.ciphertext.len() + self.salt.len() + self.iv.len() + self.ephemeral_pub_key.len(),
        );
        result.extend_from_slice(&self.ciphertext);
        result.extend_from_slice(&self.salt);
        result.extend_from_slice(&self.iv);
        result.extend_from_slice(&self.ephemeral_pub_key);
        result
    }
}

/// PBKDF2 key derivation. HMAC with BLAKE3 is used.
///
/// # Arguments
///
/// * `pwd` - Password.
/// * `salt` - Salt (optional, randomly generated when not specified, 16 bytes). Use a fixed salt for predictable results in tests only.
/// * `iterations` - Iterations (optional, by default [DEFAULT_ITERATIONS]).
///
/// # Returns
///
/// Key derivation result. The key is 32 bytes.
pub fn derive_key_pbkdf2(
    pwd: &str,
    salt: Option<&[u8; 16]>,
    iterations: Option<u32>,
) -> Result<DerivedKey, TdnCryptoError> {
    // Generate salt if not provided.
    let salt = match salt {
        Some(s) => s.to_vec(),
        None => {
            let mut s = vec![0; 16];
            rand::fill_random(&mut s).map_err(|e| {
                TdnCryptoError::DeriveKeyError(format!(
                    "Failed to generate salt: {}",
                    e.to_string()
                ))
            })?;
            s
        }
    };

    let iterations = iterations.unwrap_or(DEFAULT_ITERATIONS);

    // Derive a key using PBKDF2.
    let mut key = [0u8; 32];
    pbkdf2::<SimpleHmac<blake3::Hasher>>(&pwd.as_bytes(), &salt, iterations, &mut key).map_err(
        |e| {
            TdnCryptoError::DeriveKeyError(format!(
                "PBKDF2 key derivation failed: {}",
                e.to_string()
            ))
        },
    )?;

    Ok(DerivedKey {
        key: key.to_vec(),
        salt,
    })
}

/// HKDF key derivation. BLAKE3 is used.
///
/// # Arguments
///
/// * `secret` - Secret.
/// * `salt` - Salt (optional, randomly generated when not specified, 16 bytes). Use a fixed salt for predictable results in tests only.
/// * `output_length` - Output key length.
///
/// # Returns
///
/// Key derivation result. The key is of the specified length.
pub fn derive_key_hkdf(
    secret: &[u8],
    salt: Option<&[u8; 16]>,
    output_length: usize,
) -> Result<DerivedKey, TdnCryptoError> {
    // Generate salt if not provided.
    let salt = match salt {
        Some(s) => s.to_vec(),
        None => {
            let mut s = vec![0; 16];
            rand::fill_random(&mut s).map_err(|e| {
                TdnCryptoError::DeriveKeyError(format!(
                    "Failed to generate salt: {}",
                    e.to_string()
                ))
            })?;
            s
        }
    };

    let info = &[0u8; 0];
    let hk = hkdf::SimpleHkdf::<blake3::Hasher>::new(Some(&salt), secret);
    let mut okm = vec![0u8; output_length];
    hk.expand(info, &mut okm).map_err(|e| {
        TdnCryptoError::DeriveKeyError(format!("HKDF key derivation failed: {}", e.to_string()))
    })?;

    Ok(DerivedKey {
        key: okm.to_vec(),
        salt,
    })
}

/// AES-256 GCM symmetric encryption.
///
/// # Arguments
///
/// * `key` - Key (32 bytes).
/// * `data` - Data to encrypt.
/// * `nonce` - Nonce (optional, randomly generated when not specified, 12 bytes for GCM). Use a fixed nonce for predictable results in tests only.
///
/// # Returns
///
/// Encrypted data.
pub fn symmetric_encrypt_aes256_gcm(
    key: &[u8],
    data: &[u8],
    nonce: Option<&[u8; 12]>,
) -> Result<EncryptedData, TdnCryptoError> {
    // Generate nonce if not provided.
    let nonce = match nonce {
        Some(nonce) => nonce.to_owned(),
        None => gen_random_nonce()?,
    };

    let cipher = Aes256Gcm::new_from_slice(key).map_err(|e| {
        TdnCryptoError::EncryptionError(format!(
            "Failed to create AES-256 GCM cipher: {}",
            e.to_string()
        ))
    })?;
    let ciphertext = cipher
        .encrypt(&nonce.into(), data)
        .map_err(|e| TdnCryptoError::EncryptionError(e.to_string()))?;

    Ok(EncryptedData {
        ciphertext,
        iv: nonce.to_vec(),
    })
}

/// Perform the ECIES hybrid encryption using the given public key.
/// The key should be in SEC1 uncompressed format.
/// We have this because direct asymmetric encryption is not recommended.
/// Direct asymmetric encryption is only suitable for small and ephemeral data
/// and yet it's slower compared to all the processes involved in ECIES combined.
///
/// # Arguments
///
/// * `pub_key` - Public key (65 bytes).
/// * `data` - Data to encrypt.
/// * `ephemeral_priv_key` - Ephemeral private key (optional, randomly generated when not specified). Use a fixed key for predictable results in tests only.
/// * `salt` - Salt (optional, randomly generated when not specified, 16 bytes). Use a fixed salt for predictable results in tests only.
/// * `nonce` - Nonce (optional, randomly generated when not specified, 12 bytes for GCM). Use a fixed nonce for predictable results in tests only.
///
/// # Returns
///
/// Hybrid encrypted data.
pub fn hybrid_encrypt_ecies(
    pub_key: &[u8],
    data: &[u8],
    ephemeral_priv_key: Option<&[u8; 32]>,
    salt: Option<&[u8; 16]>,
    nonce: Option<&[u8; 12]>,
) -> Result<HybridEncryptedData, TdnCryptoError> {
    // Generate salt if not provided.
    let salt = match salt {
        Some(s) => s.to_owned(),
        None => {
            let mut s = [0u8; 16];
            rand::fill_random(&mut s).map_err(|e| {
                TdnCryptoError::EncryptionError(format!(
                    "Failed to generate salt: {}",
                    e.to_string()
                ))
            })?;
            s
        }
    };

    // Generate ephemeral key pair if not provided.
    let (ephemeral_priv_key, ephemeral_pub_key) = match ephemeral_priv_key {
        Some(bytes) => {
            let ephemeral_priv_key = k256::SecretKey::from_slice(bytes).map_err(|e| {
                TdnCryptoError::LoadKeyError(format!(
                    "Invalid ephemeral private key: {}",
                    e.to_string()
                ))
            })?;
            (ephemeral_priv_key.clone(), ephemeral_priv_key.public_key())
        }
        None => {
            let ephemeral_priv_key = k256::SecretKey::random(&mut OsRng);
            (ephemeral_priv_key.clone(), ephemeral_priv_key.public_key())
        }
    };

    // Generate nonce if not provided.
    let nonce = match nonce {
        Some(nonce) => nonce.to_owned(),
        None => gen_random_nonce()?,
    };

    // ECDH to derive a shared secret.
    let pub_key = k256::PublicKey::from_sec1_bytes(pub_key)
        .map_err(|e| TdnCryptoError::LoadKeyError(format!("ECDH failed: {}", e.to_string())))?;
    let shared_secret =
        k256::ecdh::diffie_hellman(&ephemeral_priv_key.to_nonzero_scalar(), pub_key.as_affine());

    // Derive a key using HKDF.
    let derived_key = derive_key_hkdf(&shared_secret.raw_secret_bytes().to_vec(), Some(&salt), 32)?;

    // AES-256 GCM encryption.
    let encrypted_data = symmetric_encrypt_aes256_gcm(&derived_key.key, data, Some(&nonce))?;

    Ok(HybridEncryptedData {
        ciphertext: encrypted_data.ciphertext,
        salt: salt.to_vec(),
        iv: encrypted_data.iv,
        ephemeral_pub_key: ephemeral_pub_key.to_encoded_point(false).as_bytes().into(),
    })
}

fn gen_random_nonce() -> Result<[u8; 12], TdnCryptoError> {
    let mut nonce = [0u8; 12];
    rand::fill_random(&mut nonce).map_err(|e| {
        TdnCryptoError::DeriveKeyError(format!("Failed to generate nonce: {}", e.to_string()))
    })?;
    Ok(nonce)
}
