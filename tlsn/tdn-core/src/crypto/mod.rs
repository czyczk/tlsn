//! TDN crypto utils.

use aes_gcm::{
    aead::{Aead, OsRng},
    Aes256Gcm, KeyInit,
};
use pbkdf2::{hmac::SimpleHmac, pbkdf2};
use secp256k1::Secp256k1;
use tls_core::rand;

#[derive(Clone, Debug, thiserror::Error)]
#[allow(missing_docs)]
pub enum TdnCryptoError {
    #[error("Cannot derive key: {0}")]
    DeriveKeyError(String),
    #[error("Cannot load key: {0}")]
    LoadKeyError(String),
    #[error("Encryption error: {0}")]
    EncryptionError(String),
}

pub(crate) const DEFAULT_ITERATIONS: u32 = 10_000;

/// Key generated by derivation process.
pub struct DerivedKey {
    /// Derived key.
    pub key: Vec<u8>,
    /// Salt used in the derivation process.
    pub salt: Vec<u8>,
}

/// Symmetric encryption result.
pub struct EncryptedData {
    /// Encrypted ciphertext.
    pub ciphertext: Vec<u8>,
    /// IV / nonce.
    pub iv: Vec<u8>,
}

/// Hybrid encryption result.
pub struct HybridEncryptedData {
    /// Encrypted ciphertext.
    pub ciphertext: Vec<u8>,
    /// Salt.
    pub salt: Vec<u8>,
    /// IV / nonce.
    pub iv: Vec<u8>,
    /// Ephemeral public key.
    pub ephemeral_pub_key: Vec<u8>,
}

impl EncryptedData {
    /// Serializes [EncryptedData] together with a salt. The order is ciphertext, salt, IV.
    pub fn serialize_with_nonce(&self, salt: &[u8]) -> Vec<u8> {
        let mut result = Vec::with_capacity(self.ciphertext.len() + salt.len() + self.iv.len());
        result.extend_from_slice(&self.ciphertext);
        result.extend_from_slice(&salt);
        result.extend_from_slice(&self.iv);
        result
    }
}

impl HybridEncryptedData {
    /// Serializes [HybridEncryptedData]. The order is ciphertext, salt, IV, ephemeral public key.
    pub fn serialize(&self) -> Vec<u8> {
        let mut result = Vec::with_capacity(
            self.ciphertext.len() + self.salt.len() + self.iv.len() + self.ephemeral_pub_key.len(),
        );
        result.extend_from_slice(&self.ciphertext);
        result.extend_from_slice(&self.salt);
        result.extend_from_slice(&self.iv);
        result.extend_from_slice(&self.ephemeral_pub_key);
        result
    }
}

/// PBKDF2 key derivation. HMAC with BLAKE3 is used.
///
/// # Arguments
///
/// * `pwd` - Password.
/// * `salt` - Salt (optional, randomly generated when not specified, 16 bytes). Use a fixed salt for predictable results in tests only.
/// * `iterations` - Iterations (optional, by default [DEFAULT_ITERATIONS]).
///
/// # Returns
///
/// Key derivation result. The key is 32 bytes.
pub fn derive_key_pbkdf2(
    pwd: &str,
    salt: Option<&[u8; 16]>,
    iterations: Option<u32>,
) -> Result<DerivedKey, TdnCryptoError> {
    // Generate salt if not provided.
    let salt = match salt {
        Some(s) => s.to_vec(),
        None => {
            let mut s = vec![0; 16];
            rand::fill_random(&mut s).map_err(|e| {
                TdnCryptoError::DeriveKeyError(format!(
                    "Failed to generate salt: {}",
                    e.to_string()
                ))
            })?;
            s
        }
    };

    let iterations = iterations.unwrap_or(DEFAULT_ITERATIONS);

    // Derive a key using PBKDF2.
    let mut key = [0u8; 32];
    pbkdf2::<SimpleHmac<blake3::Hasher>>(&pwd.as_bytes(), &salt, iterations, &mut key).map_err(
        |e| {
            TdnCryptoError::DeriveKeyError(format!(
                "PBKDF2 key derivation failed: {}",
                e.to_string()
            ))
        },
    )?;

    Ok(DerivedKey {
        key: key.to_vec(),
        salt,
    })
}

/// HKDF key derivation. BLAKE3 is used.
///
/// # Arguments
///
/// * `secret` - Secret.
/// * `salt` - Salt (optional, randomly generated when not specified, 16 bytes). Use a fixed salt for predictable results in tests only.
/// * `output_length` - Output key length.
///
/// # Returns
///
/// Key derivation result. The key is of the specified length.
pub fn derive_key_hkdf(
    secret: &[u8],
    salt: Option<&[u8; 16]>,
    output_length: usize,
) -> Result<DerivedKey, TdnCryptoError> {
    // Generate salt if not provided.
    let salt = match salt {
        Some(s) => s.to_vec(),
        None => {
            let mut s = vec![0; 16];
            rand::fill_random(&mut s).map_err(|e| {
                TdnCryptoError::DeriveKeyError(format!(
                    "Failed to generate salt: {}",
                    e.to_string()
                ))
            })?;
            s
        }
    };

    let info = b"";
    let hk = hkdf::SimpleHkdf::<blake3::Hasher>::new(Some(&salt), secret);
    let mut okm = vec![0u8; output_length];
    hk.expand(info, &mut okm).map_err(|e| {
        TdnCryptoError::DeriveKeyError(format!("HKDF key derivation failed: {}", e.to_string()))
    })?;

    Ok(DerivedKey {
        key: okm.to_vec(),
        salt,
    })
}

/// AES-256 GCM symmetric encryption.
///
/// # Arguments
///
/// * `key` - Key (32 bytes).
/// * `data` - Data to encrypt.
/// * `nonce` - Nonce (optional, randomly generated when not specified, 12 bytes for GCM). Use a fixed nonce for predictable results in tests only.
///
/// # Returns
///
/// Encrypted data.
pub fn symmetric_encrypt_aes256_gcm(
    key: &[u8],
    data: &[u8],
    nonce: Option<&[u8; 12]>,
) -> Result<EncryptedData, TdnCryptoError> {
    // Generate nonce if not provided.
    let nonce = match nonce {
        Some(nonce) => nonce.to_owned(),
        None => gen_random_nonce()?,
    };

    let cipher = Aes256Gcm::new_from_slice(key).map_err(|e| {
        TdnCryptoError::EncryptionError(format!(
            "Failed to create AES-256 GCM cipher: {}",
            e.to_string()
        ))
    })?;
    let ciphertext = cipher
        .encrypt(&nonce.into(), data)
        .map_err(|e| TdnCryptoError::EncryptionError(e.to_string()))?;

    Ok(EncryptedData {
        ciphertext,
        iv: nonce.to_vec(),
    })
}

/// Perform the ECIES hybrid encryption using the given public key.
/// The key should be in SEC1 uncompressed format.
/// We have this because direct asymmetric encryption is not recommended.
/// Direct asymmetric encryption is only suitable for small and ephemeral data
/// and yet it's slower compared to all the processes involved in ECIES combined.
///
/// # Arguments
///
/// * `pub_key` - Public key (65 bytes).
/// * `data` - Data to encrypt.
/// * `ephemeral_priv_key` - Ephemeral private key (optional, randomly generated when not specified). Use a fixed key for predictable results in tests only.
/// * `salt` - Salt (optional, randomly generated when not specified, 16 bytes). Use a fixed salt for predictable results in tests only.
/// * `nonce` - Nonce (optional, randomly generated when not specified, 12 bytes for GCM). Use a fixed nonce for predictable results in tests only.
///
/// # Returns
///
/// Hybrid encrypted data.
pub fn hybrid_encrypt_ecies(
    pub_key: &[u8],
    data: &[u8],
    ephemeral_priv_key: Option<&[u8; 32]>,
    salt: Option<&[u8; 16]>,
    nonce: Option<&[u8; 12]>,
) -> Result<HybridEncryptedData, TdnCryptoError> {
    // Generate salt if not provided.
    let salt = match salt {
        Some(s) => s.to_owned(),
        None => {
            let mut s = [0u8; 16];
            rand::fill_random(&mut s).map_err(|e| {
                TdnCryptoError::EncryptionError(format!(
                    "Failed to generate salt: {}",
                    e.to_string()
                ))
            })?;
            s
        }
    };

    // Generate ephemeral key pair if not provided.
    let (ephemeral_priv_key, ephemeral_pub_key) = match ephemeral_priv_key {
        Some(bytes) => {
            let ephemeral_priv_key = secp256k1::SecretKey::from_slice(bytes).map_err(|e| {
                TdnCryptoError::LoadKeyError(format!(
                    "Invalid ephemeral private key: {}",
                    e.to_string()
                ))
            })?;
            (
                ephemeral_priv_key,
                ephemeral_priv_key.public_key(&Secp256k1::new()),
            )
        }
        None => Secp256k1::new().generate_keypair(&mut OsRng),
    };

    // Generate nonce if not provided.
    let nonce = match nonce {
        Some(nonce) => nonce.to_owned(),
        None => gen_random_nonce()?,
    };

    // ECDH to derive a shared secret.
    let pub_key = secp256k1::PublicKey::from_slice(pub_key)
        .map_err(|e| TdnCryptoError::LoadKeyError(format!("ECDH failed: {}", e.to_string())))?;
    let shared_secret = secp256k1::ecdh::SharedSecret::new(&pub_key, &ephemeral_priv_key);

    // Derive a key using HKDF.
    let derived_key = derive_key_hkdf(&shared_secret.secret_bytes()[..], Some(&salt), 32)?;

    // AES-256 GCM encryption.
    let encrypted_data = symmetric_encrypt_aes256_gcm(&derived_key.key, data, Some(&nonce))?;

    Ok(HybridEncryptedData {
        ciphertext: encrypted_data.ciphertext,
        salt: salt.to_vec(),
        iv: encrypted_data.iv,
        ephemeral_pub_key: ephemeral_pub_key.serialize_uncompressed().to_vec(),
    })
}

fn gen_random_nonce() -> Result<[u8; 12], TdnCryptoError> {
    let mut nonce = [0u8; 12];
    rand::fill_random(&mut nonce).map_err(|e| {
        TdnCryptoError::DeriveKeyError(format!("Failed to generate nonce: {}", e.to_string()))
    })?;
    Ok(nonce)
}
