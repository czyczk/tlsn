use std::{collections::HashMap, sync::Arc};

use chrono::{DateTime, Utc};
use p256::ecdsa::SigningKey;
use serde::{Deserialize, Serialize};
use std::sync::Mutex;
use tdn_core::session::TdnSessionData;
use tokio::sync::Mutex as AsyncMutex;

use crate::{config::NotarizationProperties, domain::auth::AuthorizationWhitelistRecord};

/// Response object of the /session API
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NotarizationSessionResponse {
    /// Unique session id that is generated by notary and shared to prover
    pub session_id: String,
}

/// Request object of the /session API
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NotarizationSessionRequest {
    pub client_type: ClientType,
    /// Maximum data that can be sent by the prover
    pub max_sent_data: Option<usize>,
    /// Maximum data that can be received by the prover
    pub max_recv_data: Option<usize>,
}

/// Request query of the /notarize API
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NotarizationRequestQuery {
    /// Session id that is returned from /session API
    pub session_id: String,
}

/// Request query of the /tdn-collect API
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TdnCollectRequest {
    /// Session id that is returned from /session API
    pub session_id: String,
    /// Commitment to the password that protects the proof that will be generated
    pub commitment_pwd_proof_base64: String,
    /// Consumer public key
    pub pub_key_consumer_base64: String,
}

/// Types of client that the prover is using
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum ClientType {
    /// Client that has access to the transport layer
    Tcp,
    /// Client that cannot directly access transport layer, e.g. browser extension
    Websocket,
}

/// Session configuration data to be stored in temporary storage
#[derive(Clone, Debug)]
pub struct SessionData {
    pub max_sent_data: Option<usize>,
    pub max_recv_data: Option<usize>,
    pub created_at: DateTime<Utc>,
}

/// Global data that needs to be shared with the axum handlers
#[derive(Clone, Debug)]
pub struct NotaryGlobals {
    pub notary_signing_key: SigningKey,
    /// Notary blockchain EVM private key. Required in the TDN process.
    pub notary_blockchain_evm_priv_key: Option<secp256k1::SecretKey>,
    /// Notary blockchain EVM settlement address. Required in the TDN process.
    pub notary_blockchain_evm_settlement_addr: Option<String>,
    pub notarization_config: NotarizationProperties,
    /// A temporary storage to store configuration data, mainly used for WebSocket client
    pub store: Arc<AsyncMutex<HashMap<String, SessionData>>>,
    /// A storage to store TDN sessions.
    pub tdn_store: Arc<AsyncMutex<HashMap<String, TdnSessionData>>>,
    /// Whitelist of API keys for authorization purpose
    pub authorization_whitelist: Option<Arc<Mutex<HashMap<String, AuthorizationWhitelistRecord>>>>,
}

impl NotaryGlobals {
    pub fn new(
        notary_signing_key: SigningKey,
        notary_blockchain_evm_priv_key: Option<secp256k1::SecretKey>,
        notary_blockchain_evm_settlement_addr: Option<String>,
        notarization_config: NotarizationProperties,
        authorization_whitelist: Option<Arc<Mutex<HashMap<String, AuthorizationWhitelistRecord>>>>,
    ) -> Self {
        Self {
            notary_signing_key,
            notary_blockchain_evm_priv_key,
            notary_blockchain_evm_settlement_addr,
            notarization_config,
            store: Default::default(),
            tdn_store: Default::default(),
            authorization_whitelist,
        }
    }
}
